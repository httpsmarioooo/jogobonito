1. Crear el Repository validar que el repository exista
2. Crear el DTO hacer el dto, copiar y pegar los:

 DECORADORES:

 EJEMPLO
 @Data
 @Builder
 @AllArgsConstructor
 @NoArgsConstructor

 Y traer todos los private de la clase domain correspondiente


3. Agregar el controler y luego las inyecciones con su constructor:

  Inyecciones

  EJEMPLO
  private JudgePerMatchRepository judgePerMatchRepository;
  private JudgePerMatchService judgePerMatchService;

    Constructores

    EJEMPLO
    public JudgePerMatchController(JudgePerMatchRepository judgePerMatchRepository, JudgePerMatchService judgePerMatchService) {
        this.judgePerMatchRepository = judgePerMatchRepository;
        this.judgePerMatchService = judgePerMatchService;
    }

4. Crear SERVICE

EJEMPLO
public interface PlayerService {
    PlayerDTO guardarNuevoPlaye(PlayerDTO playerDTO);
}

5. Crear SERVICEIMPL

Comenzar a agregar el:

import org.springframework.stereotype.Service;
@Service

y poner el implements PlayerService

EJEMPLO
public class PlayerServiceImpl >implements PlayerService< {
}

Luego pararce en el error y undir la opcion implementar metodos:
EJEMPLO
@Override
    public PlayerDTO guardarNuevoPlaye(PlayerDTO playerDTO) {
        return null;
    }


6. Nos devolvemos al controlador y veremos que ya no esta el error en las ultimas lineas del codigo.
7. Vamos a copiar el metodo para guardar.

EJEMPLO
@PostMapping(value = "/guardarNuevoPlayer")
    public ResponseEntity<PlayerDTO> guardarNuevoPlayer(@RequestBody PlayerDTO playerDTO){
        PlayerDTO playerResponse = playerService.guardarNuevoPlayer(playerDTO);
        return new ResponseEntity<>(playerResponse, HttpStatus.CREATED);
    }

5. Crear Mapper

6. Ajustar el Controller

6. Luego nos vamos a Servicesimpl y le damos a la FX funcion y entramos a las excepciones pero en Services (solito)
7. Comenzamos a hacer las validaciones. Validaciones de la tabla dependiente a independiente IMPL
8. Ultimas validaciones en el mismo impl en la parte final---






---------------------------TEMPORADA 2----------------------------------------
POST: Para crear nuevos registros en una tabla. Se necesita en las tablas donde se puedan agregar nuevos elementos desde la aplicación.
GET: Para obtener información de la tabla. Todas las tablas deberían tenerlo, ya que siempre es útil poder consultar los datos.
PUT: Para actualizar registros existentes en la tabla. Es necesario en las tablas donde se pueden modificar los datos.

POST, GET, PUT:
stadiums,
teams,
players, TERMINADO
matches,
standings,
awards, coaches,
event_type,
judges,
judge_roles.

POST, GET (sin PUT):
goals, HAY QUE VER
assists,
match_events,
judges_per_match.
